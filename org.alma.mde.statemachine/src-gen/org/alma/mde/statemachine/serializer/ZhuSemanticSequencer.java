/*
 * generated by Xtext
 */
package org.alma.mde.statemachine.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.alma.mde.statemachine.services.ZhuGrammarAccess;
import org.alma.mde.statemachine.zhu.Region;
import org.alma.mde.statemachine.zhu.State;
import org.alma.mde.statemachine.zhu.StateMachine;
import org.alma.mde.statemachine.zhu.States;
import org.alma.mde.statemachine.zhu.StatesSeparated;
import org.alma.mde.statemachine.zhu.TopRegion;
import org.alma.mde.statemachine.zhu.Transition;
import org.alma.mde.statemachine.zhu.Transitions;
import org.alma.mde.statemachine.zhu.Triggers;
import org.alma.mde.statemachine.zhu.TriggersSeparated;
import org.alma.mde.statemachine.zhu.ZhuPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ZhuSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ZhuGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ZhuPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ZhuPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case ZhuPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case ZhuPackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case ZhuPackage.STATES:
				sequence_States(context, (States) semanticObject); 
				return; 
			case ZhuPackage.STATES_SEPARATED:
				sequence_StatesSeparated(context, (StatesSeparated) semanticObject); 
				return; 
			case ZhuPackage.TOP_REGION:
				sequence_TopRegion(context, (TopRegion) semanticObject); 
				return; 
			case ZhuPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case ZhuPackage.TRANSITIONS:
				sequence_Transitions(context, (Transitions) semanticObject); 
				return; 
			case ZhuPackage.TRIGGERS:
				sequence_Triggers(context, (Triggers) semanticObject); 
				return; 
			case ZhuPackage.TRIGGERS_SEPARATED:
				sequence_TriggersSeparated(context, (TriggersSeparated) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (name=ID states=States regions+=Region* transitions=Transitions?)
	 */
	protected void sequence_Region(EObject context, Region semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     region=TopRegion
	 */
	protected void sequence_StateMachine(EObject context, StateMachine semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ZhuPackage.Literals.STATE_MACHINE__REGION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZhuPackage.Literals.STATE_MACHINE__REGION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStateMachineAccess().getRegionTopRegionParserRuleCall_2_0(), semanticObject.getRegion());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_State(EObject context, State semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ZhuPackage.Literals.STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZhuPackage.Literals.STATE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStateAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (firstState=State followingStates+=State*)
	 */
	protected void sequence_StatesSeparated(EObject context, StatesSeparated semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     states=StatesSeparated
	 */
	protected void sequence_States(EObject context, States semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ZhuPackage.Literals.STATES__STATES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZhuPackage.Literals.STATES__STATES));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStatesAccess().getStatesStatesSeparatedParserRuleCall_3_0(), semanticObject.getStates());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (states=States regions+=Region* transitions=Transitions?)
	 */
	protected void sequence_TopRegion(EObject context, TopRegion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (source=[State|ID] target=[State|ID] triggers=Triggers? guard=STRING? behaviour=STRING?)
	 */
	protected void sequence_Transition(EObject context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (firstTransition=Transition followingTransitions+=Transition*)
	 */
	protected void sequence_Transitions(EObject context, Transitions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (firstTrigger=STRING followingTriggers+=STRING*)
	 */
	protected void sequence_TriggersSeparated(EObject context, TriggersSeparated semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     triggers=TriggersSeparated
	 */
	protected void sequence_Triggers(EObject context, Triggers semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ZhuPackage.Literals.TRIGGERS__TRIGGERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ZhuPackage.Literals.TRIGGERS__TRIGGERS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTriggersAccess().getTriggersTriggersSeparatedParserRuleCall_3_0(), semanticObject.getTriggers());
		feeder.finish();
	}
}
